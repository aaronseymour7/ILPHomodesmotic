#!/usr/bin/env python3

import sys
import argparse
from rdkit import Chem
from rdkit.Chem import Draw
from rdkit.Chem import AllChem
from pulp import LpProblem, LpVariable, lpSum, LpMinimize, LpInteger, PULP_CBC_CMD, LpStatus




def Isogyric(input_mol, lhs_required=None, rhs_required=None, Substruct=None, Replacement=None):

    wildcard_reactants = [
        Chem.MolFromSmiles("[H][H]"),
    ]
    wildcard_products = [
        Chem.MolFromSmiles("[*]"),
    ]
    wildcard_reactants = sorted(wildcard_reactants, key=lambda x: x.GetNumAtoms(), reverse=True)
    wildcard_products = sorted(wildcard_products, key=lambda x: x.GetNumAtoms(), reverse=True)
    def append_unique(mol_list, mol):
        mol_smiles = Chem.MolToSmiles(mol)
        # Remove any molecules that match by SMILES
        mol_list[:] = [m for m in mol_list if Chem.MolToSmiles(m) != mol_smiles]
        mol_list.append(mol)                           
    def map_atoms(matched_structure, mol):
        p = Chem.AdjustQueryParameters.NoAdjustments()
        p.makeDummiesQueries = True
        query = Chem.AdjustQueryProperties(matched_structure, p) 
        matches = mol.GetSubstructMatches(query)
        if matches:
            return matches
        else:
            print(f"No atom mapping found for substructure: {Chem.MolToSmiles(matched_structure)}")
        return matched_structure
    def match_substructure(mol, sub):
        p = Chem.AdjustQueryParameters.NoAdjustments()
        p.makeDummiesQueries = True
        substructure = Chem.AdjustQueryProperties(sub, p)
        match = mol.HasSubstructMatch(substructure)
        return match
                               

    def count_atoms(mol):
        atom_counts = {}
        if isinstance(mol, Chem.Atom):
            key = (mol.GetSymbol())
            atom_counts[key] = atom_counts.get(key, 0) + 1
            return atom_counts
        for atom in mol.GetAtoms():
        
            key = (atom.GetSymbol())
            atom_counts[key] = atom_counts.get(key, 0) + 1
        return atom_counts
    def product_options(mol):
      
    
    
        matched_products = []
    
    
        for product in wildcard_products:
            if match_substructure(mol, product):
                matched_products.append(product)
    
        # Map atom IDs from reactants/products to the molecule
    
        mapped_products = []
    
        for product in matched_products:
            matches = map_atoms(product, mol)  # Get matched atom indices
        
            if not matches:
                continue  # Skip if no matches found
    
            for match in matches:
                # Convert to an editable molecule
                rw_product = Chem.RWMol(product)
    
                for wild_idx, mol_idx in enumerate(match):  
                    product_atom = rw_product.GetAtomWithIdx(wild_idx)  # Get atom in product
                    mol_atom = mol.GetAtomWithIdx(mol_idx)  # Get corresponding atom in mol
    
                    if product_atom.GetAtomicNum() == 0:  # If it's a wildcard atom
                        
                
                        
                        
                        new_atomic_num = mol_atom.GetAtomicNum()  # Get atomic number from mol
                        product_atom.SetAtomicNum(new_atomic_num)  # Assign atomic number
                        product_atom.SetNoImplicit(False)
                        product_atom.SetNumExplicitHs(0) 
                        #product_atom.SetNoImplicit(False)
                        
                        
                        
                       
                
                Chem.SanitizeMol(rw_product)
                mapped_products.append(Chem.AddHs(rw_product.GetMol())) # Convert back to immutable Mol
                 
    
    
    
        unique_products = []
        unique_smiles = set()
        
        for prod in mapped_products:
    
                smiles = Chem.MolToSmiles(prod)  # Convert to SMILES for easy comparison
                if smiles not in unique_smiles:
                    unique_smiles.add(smiles)
                    unique_products.append(prod)
    
        return unique_products
    def reactant_options(unique_products):
        unique_atoms = set()  # Use a set to store unique atoms
        for molecule in unique_products:
            for atom in molecule.GetAtoms():
                mol = Chem.RWMol()
                new_atom = Chem.Atom(atom.GetAtomicNum())  # Copy the atom
                atom_idx = mol.AddAtom(new_atom)  # Add it to the molecule
    
                # Add explicit hydrogens
                Chem.SanitizeMol(mol)
                mol = mol.GetMol()
                unique_atoms.add(mol)  # Add atom to set (duplicates are automatically ignored)
        return list(unique_atoms)  # Convert back to list for return
    def Balance(input_mol):
        prob = LpProblem("Isogyric_Balancing", LpMinimize)
        
        dummy = input_mol
        if Substruct and Replacement:
            if isinstance(Substruct, list) and isinstance(Replacement, list):
                for sub, rep in zip(Substruct, Replacement):
                    dummy = Chem.ReplaceSubstructs(dummy, sub, rep, True)[0]
            elif isinstance(Substruct, Chem.Mol) and isinstance(Replacement, Chem.Mol):
                dummy = Chem.ReplaceSubstructs(dummy, Substruct, Replacement, True)[0]
        rhs_options = product_options(dummy)
        for atom in rhs_options:
            Chem.AddHs(atom)
        lhs_addition_options = reactant_options(rhs_options)
        lhs_addition_options.append(input_mol)
        lhs_addition_options.append(Chem.MolFromSmiles("[H][H]"))
        input_index = lhs_addition_options.index(input_mol)
        if lhs_required:
            if isinstance (lhs_required, list):
                for mol in lhs_required:
                    lhs_addition_options.append(mol)
            elif isinstance (lhs_required, Chem.Mol):
                    lhs_addition_options.append(lhs_required)
                
        if rhs_required:
            if isinstance (rhs_required, list):
                for mol in rhs_required:
                    append_unique(rhs_options, mol)
            elif isinstance (rhs_required, Chem.Mol):
                append_unique(rhs_options, rhs_required)
        
        
        x_vars = [LpVariable(f"x_{i}", 0, None, LpInteger) for i in range(len(rhs_options))]
        y_vars = [LpVariable(f"y_{j}", 0, None, LpInteger) for j in range(len(lhs_addition_options))]
        prob += y_vars[input_index] == 1       
        if lhs_required:
            if isinstance (lhs_required, list):
                for mol in lhs_required:
                    lhs_r_idx = lhs_addition_options.index(mol) 
                    prob += y_vars[lhs_r_idx] == 1
            elif isinstance (lhs_required, Chem.Mol):
                lhs_r_idx = lhs_addition_options.index(lhs_required) 
                prob += y_vars[lhs_r_idx] == 1
        if rhs_required:
            if isinstance (rhs_required, list):
                for mol in rhs_required:
                    rhs_r_idx = rhs_options.index(mol) 
                    prob += x_vars[rhs_r_idx] == 1
            elif isinstance (rhs_required, Chem.Mol):
                rhs_r_idx = rhs_options.index(rhs_required) 
                prob += x_vars[rhs_r_idx] == 1
        if not rhs_options:
            print("Error: No RHS molecules found.")
            return [], []
    
        atom_types_rhs = [count_atoms(mol) for mol in rhs_options]
        atom_types_lhs = [count_atoms(mol) for mol in lhs_addition_options]
        
        for t in set().union(*atom_types_rhs, *atom_types_lhs):
            prob += lpSum(x_vars[i] * atom_types_rhs[i].get(t, 0) for i in range(len(rhs_options))) == \
                    lpSum(y_vars[j] * atom_types_lhs[j].get(t, 0) for j in range(len(lhs_addition_options)))
    
        solver = PULP_CBC_CMD(msg=False)

        prob.solve(solver)

        solution_x = [int(var.varValue) for var in x_vars]
        solution_y = [int(var.varValue) for var in y_vars]
    
        balanced_rhs = [(rhs_options[i], solution_x[i]) for i in range(len(rhs_options)) if solution_x[i] > 0]
        balanced_lhs = [(lhs_addition_options[j], solution_y[j]) for j in range(len(lhs_addition_options)) if solution_y[j] > 0]
        print("Status:", LpStatus[prob.status])
        return balanced_rhs, balanced_lhs, LpStatus[prob.status]
    return Balance(input_mol)


def Isodesmic(input_mol, lhs_required=None, rhs_required=None, Substruct=None, Replacement=None):
    input_mol = Chem.RemoveHs(input_mol)
    wildcard_reactants = [
        Chem.MolFromSmiles("[*]"),
    ]
    wildcard_products = [
        Chem.MolFromSmiles("[*][*]"),
        Chem.MolFromSmiles("[*]=[*]"),
        Chem.MolFromSmiles("[*]#[*]"),
    ]
    wildcard_reactants = sorted(wildcard_reactants, key=lambda x: x.GetNumAtoms(), reverse=True)
    wildcard_products = sorted(wildcard_products, key=lambda x: x.GetNumAtoms(), reverse=True)
    def append_unique(mol_list, mol):
        mol_smiles = Chem.MolToSmiles(mol)
        # Remove any molecules that match by SMILES
        mol_list[:] = [m for m in mol_list if Chem.MolToSmiles(m) != mol_smiles]
        mol_list.append(mol)                           
    def map_atoms(matched_structure, mol):
        p = Chem.AdjustQueryParameters.NoAdjustments()
        p.makeDummiesQueries = True
        query = Chem.AdjustQueryProperties(matched_structure, p) 
        matches = mol.GetSubstructMatches(query)
        if matches:
            return matches
        else:
            print(f"No atom mapping found for substructure: {Chem.MolToSmiles(matched_structure)}")
        return matched_structure
    def match_substructure(mol, sub):
        p = Chem.AdjustQueryParameters.NoAdjustments()
        p.makeDummiesQueries = True
        substructure = Chem.AdjustQueryProperties(sub, p)
        match = mol.HasSubstructMatch(substructure)
        return match
                               
    def count_bonds(mol):
        bond_counts = {}
        for bond in mol.GetBonds():
            atom1 = bond.GetBeginAtom()
            atom2 = bond.GetEndAtom()
    
            # Create a tuple where atom order doesn't matter by sorting the atoms based on their symbol and hybridization
            atom_pair = tuple(sorted([atom1.GetSymbol(), atom2.GetSymbol()]))
    
            bond_type = (atom_pair, bond.GetBondType())
            bond_counts[bond_type] = bond_counts.get(bond_type, 0) + 1
    
        return bond_counts
    def count_atoms(mol):
        atom_counts = {}
        if isinstance(mol, Chem.Atom):
            key = (mol.GetSymbol())
            atom_counts[key] = atom_counts.get(key, 0) + 1
            return atom_counts
        for atom in mol.GetAtoms():
            if atom.GetSymbol() !='H':
                key = (atom.GetSymbol())
                atom_counts[key] = atom_counts.get(key, 0) + 1
        return atom_counts
    def product_options(mol):
    
    
        matched_products = []
    
    
        for product in wildcard_products:
            if match_substructure(mol, product):
                matched_products.append(product)
    
        # Map atom IDs from reactants/products to the molecule
    
        mapped_products = []
    
        for product in matched_products:
            matches = map_atoms(product, mol)  # Get matched atom indices
        
            if not matches:
                continue  # Skip if no matches found
    
            for match in matches:
                # Convert to an editable molecule
                rw_product = Chem.RWMol(product)
    
                for wild_idx, mol_idx in enumerate(match):  
                    product_atom = rw_product.GetAtomWithIdx(wild_idx)  # Get atom in product
                    mol_atom = mol.GetAtomWithIdx(mol_idx)  # Get corresponding atom in mol
    
                    if product_atom.GetAtomicNum() == 0:  # If it's a wildcard atom
                        
                
                        
                        
                        new_atomic_num = mol_atom.GetAtomicNum()  # Get atomic number from mol
                        product_atom.SetAtomicNum(new_atomic_num)  # Assign atomic number
                        product_atom.SetNoImplicit(False)
                        
                        
                        
                       
                
                Chem.SanitizeMol(rw_product)
                mapped_products.append(rw_product.GetMol()) # Convert back to immutable Mol
                 
    
    
    
        unique_products = []
        unique_smiles = set()
        
        for prod in mapped_products:
    
                smiles = Chem.MolToSmiles(prod)  # Convert to SMILES for easy comparison
                if smiles not in unique_smiles:
                    unique_smiles.add(smiles)
                    unique_products.append(prod)
    
        return unique_products
    def reactant_options(unique_products):
        unique_atoms = set()  # Use a set to store unique atoms
        for molecule in unique_products:
            for atom in molecule.GetAtoms():
                mol = Chem.RWMol()
                new_atom = Chem.Atom(atom.GetAtomicNum())  # Copy the atom
                atom_idx = mol.AddAtom(new_atom)  # Add it to the molecule
    
                # Add explicit hydrogens
                Chem.SanitizeMol(mol)
                mol = mol.GetMol()
                unique_atoms.add(mol)  # Add atom to set (duplicates are automatically ignored)
        return list(unique_atoms)  # Convert back to list for return
    def Balance(input_mol):
        prob = LpProblem("Isodesmic_Balancing", LpMinimize)
        
        dummy = input_mol
        if Substruct and Replacement:
            if isinstance(Substruct, list) and isinstance(Replacement, list):
                for sub, rep in zip(Substruct, Replacement):
                    dummy = Chem.ReplaceSubstructs(dummy, sub, rep, True)[0]
            elif isinstance(Substruct, Chem.Mol) and isinstance(Replacement, Chem.Mol):
                dummy = Chem.ReplaceSubstructs(dummy, Substruct, Replacement, True)[0]
        rhs_options = product_options(dummy)
        lhs_addition_options = reactant_options(rhs_options)
        lhs_addition_options.append(input_mol)
        input_index = lhs_addition_options.index(input_mol)
        if lhs_required:
            if isinstance (lhs_required, list):
                for mol in lhs_required:
                    lhs_addition_options.append(mol)
            elif isinstance (lhs_required, Chem.Mol):
                    lhs_addition_options.append(lhs_required)
                
        if rhs_required:
            if isinstance (rhs_required, list):
                for mol in rhs_required:
                    append_unique(rhs_options, mol)
            elif isinstance (rhs_required, Chem.Mol):
                append_unique(rhs_options, rhs_required)
        

        x_vars = [LpVariable(f"x_{i}", 0, None, LpInteger) for i in range(len(rhs_options))]
        y_vars = [LpVariable(f"y_{j}", 0, None, LpInteger) for j in range(len(lhs_addition_options))]
        prob += y_vars[input_index] == 1       
        if lhs_required:
            if isinstance (lhs_required, list):
                for mol in lhs_required:
                    lhs_r_idx = lhs_addition_options.index(mol) 
                    prob += y_vars[lhs_r_idx] == 1
            elif isinstance (lhs_required, Chem.Mol):
                lhs_r_idx = lhs_addition_options.index(lhs_required) 
                prob += y_vars[lhs_r_idx] == 1
        if rhs_required:
            if isinstance (rhs_required, list):
                for mol in rhs_required:
                    rhs_r_idx = rhs_options.index(mol) 
                    prob += x_vars[rhs_r_idx] == 1
            elif isinstance (rhs_required, Chem.Mol):
                rhs_r_idx = rhs_options.index(rhs_required) 
                prob += x_vars[rhs_r_idx] == 1
    
        if not rhs_options:
            print("Error: No RHS molecules found.")
            return [], []
    
        bond_types_rhs = [count_bonds(mol) for mol in rhs_options]
        bond_types_lhs = [count_bonds(mol) for mol in lhs_addition_options]
        atom_types_rhs = [count_atoms(mol) for mol in rhs_options]
        atom_types_lhs = [count_atoms(mol) for mol in lhs_addition_options]
        
        for k in set().union(*bond_types_rhs, *bond_types_lhs):
            prob += lpSum(x_vars[i] * bond_types_rhs[i].get(k, 0) for i in range(len(rhs_options))) == \
                    lpSum(y_vars[j] * bond_types_lhs[j].get(k, 0) for j in range(len(lhs_addition_options)))
        for t in set().union(*atom_types_rhs, *atom_types_lhs):
            prob += lpSum(x_vars[i] * atom_types_rhs[i].get(t, 0) for i in range(len(rhs_options))) == \
                    lpSum(y_vars[j] * atom_types_lhs[j].get(t, 0) for j in range(len(lhs_addition_options)))
    
        solver = PULP_CBC_CMD(msg=False)
        prob.solve(solver)
        
        solution_x = [int(var.varValue) for var in x_vars]
        solution_y = [int(var.varValue) for var in y_vars]
    
        balanced_rhs = [(rhs_options[i], solution_x[i]) for i in range(len(rhs_options)) if solution_x[i] > 0]
        balanced_lhs = [(lhs_addition_options[j], solution_y[j]) for j in range(len(lhs_addition_options)) if solution_y[j] > 0]
        print("Solver status:", LpStatus[prob.status])
        return balanced_rhs, balanced_lhs, LpStatus[prob.status]
    return Balance(input_mol)

    
def Hypohomodesmotic(input_mol, lhs_required=None, rhs_required=None, Substruct=None, Replacement=None):
    wildcard_reactants = [
        Chem.MolFromSmiles("[*][*]"),
        Chem.MolFromSmiles("[*]=[*]"),
        Chem.MolFromSmiles("[*]#[*]"),
    ]
    wildcard_products = [
        Chem.MolFromSmiles("[*][*][*]"),
        Chem.MolFromSmiles("[*]=[*][*]"),
        Chem.MolFromSmiles("[*]#[*][*]"),
        Chem.MolFromSmiles("[*][*](*)[*]"),
        Chem.MolFromSmiles("[*][*](=[*])[*]"),
        Chem.MolFromSmiles("[*][*@]([*])([*])[*]"),
        Chem.MolFromSmiles("[*]=[*]=[*]"),    
    ]
    wildcard_reactants = sorted(wildcard_reactants, key=lambda x: x.GetNumAtoms(), reverse=True)
    wildcard_products = sorted(wildcard_products, key=lambda x: x.GetNumAtoms(), reverse=True)
    def append_unique(mol_list, mol):
        mol_smiles = Chem.MolToSmiles(mol)
        # Remove any molecules that match by SMILES
        mol_list[:] = [m for m in mol_list if Chem.MolToSmiles(m) != mol_smiles]
        mol_list.append(mol)                           
    def map_atoms(matched_structure, mol):
        p = Chem.AdjustQueryParameters.NoAdjustments()
        p.makeDummiesQueries = True
        query = Chem.AdjustQueryProperties(matched_structure, p) 
        matches = mol.GetSubstructMatches(query)
        if matches:
            return matches
        else:
            print(f"No atom mapping found for substructure: {Chem.MolToSmiles(matched_structure)}")
        return matched_structure
    def match_substructure(mol, sub):
        p = Chem.AdjustQueryParameters.NoAdjustments()
        p.makeDummiesQueries = True
        substructure = Chem.AdjustQueryProperties(sub, p)
        match = mol.HasSubstructMatch(substructure)
        return match
                               
    def count_hydrogens(mol):
        mol = Chem.AddHs(mol)
        hydrogen_counts = {}
        mol = Chem.MolFromSmiles(Chem.MolToSmiles(mol))
        for atom in mol.GetAtoms():
            key = (atom.GetSymbol(), atom.GetNumExplicitHs())
            hydrogen_counts[key] = hydrogen_counts.get(key, 0) + 1
        return hydrogen_counts
    def count_atoms(mol):
        mol = Chem.RemoveHs(mol)
        atom_counts = {}
        mol = Chem.MolFromSmiles(Chem.MolToSmiles(mol))
        for atom in mol.GetAtoms():
            key = (atom.GetSymbol(), atom.GetHybridization())
            atom_counts[key] = atom_counts.get(key, 0) + 1
        return atom_counts
    def product_options(mol):
    
    
        matched_products = []
    
    
        for product in wildcard_products:
            if match_substructure(mol, product):
                matched_products.append(product)
    
        # Map atom IDs from reactants/products to the molecule
    
        mapped_products = []
    
        for product in matched_products:
            matches = map_atoms(product, mol)  # Get matched atom indices
        
            if not matches:
                continue  # Skip if no matches found
    
            for match in matches:
                # Convert to an editable molecule
                rw_product = Chem.RWMol(product)
    
                for wild_idx, mol_idx in enumerate(match):  
                    product_atom = rw_product.GetAtomWithIdx(wild_idx)  # Get atom in product
                    mol_atom = mol.GetAtomWithIdx(mol_idx)  # Get corresponding atom in mol
    
                    if product_atom.GetAtomicNum() == 0:  # If it's a wildcard atom
                        
                
                        
                        
                        new_atomic_num = mol_atom.GetAtomicNum()  # Get atomic number from mol
                        product_atom.SetAtomicNum(new_atomic_num)  # Assign atomic number
                        product_atom.SetNoImplicit(False)
                        
                        
                        
                       
                
                Chem.SanitizeMol(rw_product)
                mapped_products.append(rw_product.GetMol()) # Convert back to immutable Mol
                 
    
    
    
        unique_products = []
        unique_smiles = set()
        
        for prod in mapped_products:
    
                smiles = Chem.MolToSmiles(prod)  # Convert to SMILES for easy comparison
                if smiles not in unique_smiles:
                    unique_smiles.add(smiles)
                    unique_products.append(prod)
    
        return unique_products
    def reactant_options(unique_products):
        matched_reactants = []
        mapped_reactants = []
    
        for rhs_product in unique_products:  # Iterate over RHS products
            for reactant in wildcard_reactants:  # Iterate over wildcard reactants
                if match_substructure(rhs_product, reactant):  # Check if reactant matches product
                    matched_reactants.append((reactant, rhs_product))  # Store pair
    
        for reactant, rhs_product in matched_reactants:
            matches = map_atoms(reactant, rhs_product)  # Get atom mapping
            if not matches:
                continue  # Skip unmatched reactants
    
            rw_reactant = Chem.RWMol(reactant)  # Editable reactant molecule
            for match in matches:
                for wild_idx, prod_idx in enumerate(match):  
                    reactant_atom = rw_reactant.GetAtomWithIdx(wild_idx)
                    product_atom = rhs_product.GetAtomWithIdx(prod_idx)
    
                    if reactant_atom.GetAtomicNum() == 0:  # If it's a wildcard atom
                        new_atomic_num = product_atom.GetAtomicNum()  # Assign atomic number from product
                        reactant_atom.SetAtomicNum(new_atomic_num)
                        reactant_atom.SetNoImplicit(False)
                        new_atomic_num = product_atom.GetAtomicNum()  # Get atomic number from mol
                        reactant_atom.SetAtomicNum(new_atomic_num)  # Assign atomic number
                        reactant_atom.SetNoImplicit(False)
                Chem.SanitizeMol(rw_reactant)
                mapped_reactants.append(rw_reactant.GetMol())
                  # Convert back to immutable Mol
    
    
        # Ensure uniqueness of mapped reactants
        unique_reactants = []
        unique_smiles = set()
        
        for reactant in mapped_reactants:
            smiles = Chem.MolToSmiles(reactant)  
            if smiles not in unique_smiles:
                unique_smiles.add(smiles)
                unique_reactants.append(reactant)
    
        return unique_reactants
    
    def Balance(input_mol):
        prob = LpProblem("Hypohomodesmotic_Balancing", LpMinimize)
        
        dummy = input_mol
        if Substruct and Replacement:
            if isinstance(Substruct, list) and isinstance(Replacement, list):
                for sub, rep in zip(Substruct, Replacement):
                    dummy = Chem.ReplaceSubstructs(dummy, sub, rep, True)[0]
            elif isinstance(Substruct, Chem.Mol) and isinstance(Replacement, Chem.Mol):
                dummy = Chem.ReplaceSubstructs(dummy, Substruct, Replacement, True)[0]
        rhs_options = product_options(dummy)
        lhs_addition_options = reactant_options(rhs_options)
        lhs_addition_options.append(input_mol)
        input_index = lhs_addition_options.index(input_mol)
        if lhs_required:
            if isinstance (lhs_required, list):
                for mol in lhs_required:
                    lhs_addition_options.append(mol)
            elif isinstance (lhs_required, Chem.Mol):
                    lhs_addition_options.append(lhs_required)
                
        if rhs_required:
            if isinstance (rhs_required, list):
                for mol in rhs_required:
                    append_unique(rhs_options, mol)
            elif isinstance (rhs_required, Chem.Mol):
                append_unique(rhs_options, rhs_required)
        
        
        x_vars = [LpVariable(f"x_{i}", 0, None, LpInteger) for i in range(len(rhs_options))]
        y_vars = [LpVariable(f"y_{j}", 0, None, LpInteger) for j in range(len(lhs_addition_options))]
        prob += y_vars[input_index] == 1       
        if lhs_required:
            if isinstance (lhs_required, list):
                for mol in lhs_required:
                    lhs_r_idx = lhs_addition_options.index(mol) 
                    prob += y_vars[lhs_r_idx] == 1
            elif isinstance (lhs_required, Chem.Mol):
                lhs_r_idx = lhs_addition_options.index(lhs_required) 
                prob += y_vars[lhs_r_idx] == 1
        if rhs_required:
            if isinstance (rhs_required, list):
                for mol in rhs_required:
                    rhs_r_idx = rhs_options.index(mol) 
                    prob += x_vars[rhs_r_idx] == 1
            elif isinstance (rhs_required, Chem.Mol):
                rhs_r_idx = rhs_options.index(rhs_required) 
                prob += x_vars[rhs_r_idx] == 1
        
        
    

    
        if not rhs_options:
            print("Error: No RHS molecules found.")
            return [], []
    
        atom_types_rhs = [count_atoms(mol) for mol in rhs_options]
        atom_types_lhs = [count_atoms(mol) for mol in lhs_addition_options]
        hydrogen_rhs = [count_hydrogens(mol) for mol in rhs_options]
        hydrogen_lhs = [count_hydrogens(mol) for mol in lhs_addition_options]
    
        for k in set().union(*atom_types_rhs, *atom_types_lhs):
            prob += lpSum(x_vars[i] * atom_types_rhs[i].get(k, 0) for i in range(len(rhs_options))) == \
                    lpSum(y_vars[j] * atom_types_lhs[j].get(k, 0) for j in range(len(lhs_addition_options)))
    
        for t in set().union(*hydrogen_rhs, *hydrogen_lhs):
            prob += lpSum(x_vars[i] * hydrogen_rhs[i].get(t, 0) for i in range(len(rhs_options))) == \
                    lpSum(y_vars[j] * hydrogen_lhs[j].get(t, 0) for j in range(len(lhs_addition_options)))
    
        solver = PULP_CBC_CMD(msg=False)
        prob.solve(solver)
        solution_x = [int(var.varValue) for var in x_vars]
        solution_y = [int(var.varValue) for var in y_vars]
    
        balanced_rhs = [(rhs_options[i], solution_x[i]) for i in range(len(rhs_options)) if solution_x[i] > 0]
        balanced_lhs = [(lhs_addition_options[j], solution_y[j]) for j in range(len(lhs_addition_options)) if solution_y[j] > 0]
        print("Solver status:", LpStatus[prob.status])
        return balanced_rhs, balanced_lhs, LpStatus[prob.status]
    return Balance(input_mol)


def Homodesmotic(input_mol, lhs_required=None, rhs_required=None, Substruct=None, Replacement=None):
    wildcard_reactants = [
        Chem.MolFromSmiles("[*]=[*]"),
        Chem.MolFromSmiles("[*][*]=[*][*]"),
        Chem.MolFromSmiles("[*][*]"),
        Chem.MolFromSmiles("[*]#[*]"),
        Chem.MolFromSmiles("[*]=[*][*]"),
        Chem.MolFromSmiles("[*]#[*][*]"),
    ]
    
    wildcard_products = [
        Chem.MolFromSmiles("[*][*][*]"),
        Chem.MolFromSmiles("[*]=[*][*]"),
        Chem.MolFromSmiles("[*][*]#[*]"),
        Chem.MolFromSmiles("[*]=[*]=[*]"),
        Chem.MolFromSmiles("[*][*]([*])[*]"),
        Chem.MolFromSmiles("[*][*](=[*])[*]"),
        Chem.MolFromSmiles("[*][*@]([*])([*])[*]"),
        Chem.MolFromSmiles("[*]=[*]=[*]=[*]"),
        Chem.MolFromSmiles("[*]=[*][*]#[*]"),
        Chem.MolFromSmiles("[*]#[*][*]#[*]"),
        Chem.MolFromSmiles("[*][*](=[*])[*]=[*]"),
        Chem.MolFromSmiles("[*]=[*][*]=[*]"),
        Chem.MolFromSmiles("[*][*](=[*])[*]#[*]"),
        #Chem.MolFromSmiles("[*][*]=[*][*]"),
    ]
    
    wildcard_reactants = sorted(wildcard_reactants, key=lambda x: x.GetNumAtoms(), reverse=True)
    wildcard_products = sorted(wildcard_products, key=lambda x: x.GetNumAtoms(), reverse=True)
    def map_atoms(matched_structure, mol):
        p = Chem.AdjustQueryParameters.NoAdjustments()
        p.makeDummiesQueries = True
        query = Chem.AdjustQueryProperties(matched_structure, p) 
        matches = mol.GetSubstructMatches(query)
        if matches:
            return matches
        else:
            print(f"No atom mapping found for substructure: {Chem.MolToSmiles(matched_structure)}")
        return matched_structure
    def match_substructure(mol, sub):
        p = Chem.AdjustQueryParameters.NoAdjustments()
        p.makeDummiesQueries = True
        substructure = Chem.AdjustQueryProperties(sub, p)
        match = mol.HasSubstructMatch(substructure)
        return match
    def append_unique(mol_list, mol):
        mol_smiles = Chem.MolToSmiles(mol)
        # Remove any molecules that match by SMILES
        mol_list[:] = [m for m in mol_list if Chem.MolToSmiles(m) != mol_smiles]
        mol_list.append(mol)
            
    def product_options(mol):
        
        
        # Search for matching substructures (reactants and products)
        mol= Chem.RemoveHs(mol)
        matched_products = []
        for product in wildcard_products:
            if match_substructure(mol, product):
                matched_products.append(product)
        # Map atom IDs from reactants/products to the molecule
        mapped_products = []
        for product in matched_products:
            matches = map_atoms(product, mol)  # Get matched atom indices    
            if not matches:
                continue  # Skip if no matches found
            for match in matches:
                # Convert to an editable molecule
                rw_product = Chem.RWMol(product)
                for wild_idx, mol_idx in enumerate(match):  
                    product_atom = rw_product.GetAtomWithIdx(wild_idx)  # Get atom in product
                    mol_atom = mol.GetAtomWithIdx(mol_idx)  # Get corresponding atom in mol
                    if product_atom.GetAtomicNum() == 0:  # If it's a wildcard atom
                        new_atomic_num = mol_atom.GetAtomicNum()  # Get atomic number from mol
                        product_atom.SetAtomicNum(new_atomic_num)  # Assign atomic number
                        product_atom.SetNoImplicit(False)
                try:
                    if Chem.SanitizeMol(rw_product):
                        Chem.SanitizeMol(rw_product)
                except Exception as e:
                    continue
                mapped_products.append(rw_product.GetMol()) # Convert back to immutable Mol
        #return mapped_products
        unique_products = []
        unique_smiles = set()    
        for prod in mapped_products:
                prod = Chem.AddHs(prod)
                smiles = Chem.MolToSmiles(prod)  # Convert to SMILES for easy comparison
                if smiles not in unique_smiles:
                    unique_smiles.add(smiles)
                    unique_products.append(prod)
        return unique_products
    def reactant_options(unique_products):
        matched_reactants = []
        mapped_reactants = []
    
        for rhs_product in unique_products:  # Iterate over RHS products
            for reactant in wildcard_reactants:  # Iterate over wildcard reactants
                if match_substructure(rhs_product, reactant):  # Check if reactant matches product
                    matched_reactants.append((reactant, rhs_product))  # Store pair
    
        for reactant, rhs_product in matched_reactants:
            matches = map_atoms(reactant, rhs_product)  # Get atom mapping
            if not matches:
                continue  # Skip unmatched reactants
    
            rw_reactant = Chem.RWMol(reactant)  # Editable reactant molecule
            for match in matches:
                for wild_idx, prod_idx in enumerate(match):  
                    reactant_atom = rw_reactant.GetAtomWithIdx(wild_idx)
                    product_atom = rhs_product.GetAtomWithIdx(prod_idx)
    
                    if reactant_atom.GetAtomicNum() == 0:  # If it's a wildcard atom
                        new_atomic_num = product_atom.GetAtomicNum()  # Assign atomic number from product
                        reactant_atom.SetAtomicNum(new_atomic_num)
                        reactant_atom.SetNoImplicit(False)
                        new_atomic_num = product_atom.GetAtomicNum()  # Get atomic number from mol
                        reactant_atom.SetAtomicNum(new_atomic_num)  # Assign atomic number
                        reactant_atom.SetNoImplicit(False)
                Chem.SanitizeMol(rw_reactant)
                mapped_reactants.append(rw_reactant.GetMol())
                  # Convert back to immutable Mol
    
    
        unique_reactants = []
        unique_smiles = set()
        
        for reactant in mapped_reactants:
            reactant = Chem.AddHs(reactant)
            smiles = Chem.MolToSmiles(reactant)  
            if smiles not in unique_smiles:
                unique_smiles.add(smiles)
                unique_reactants.append(reactant)
    
    
        return unique_reactants
    
    def Balance(input_mol):
        prob = LpProblem("Chemical_Balancing", LpMinimize)
        
        dummy = input_mol
        if Substruct and Replacement:
            if isinstance(Substruct, list) and isinstance(Replacement, list):
                for sub, rep in zip(Substruct, Replacement):
                    dummy = Chem.ReplaceSubstructs(dummy, sub, rep, True)[0]
            elif isinstance(Substruct, Chem.Mol) and isinstance(Replacement, Chem.Mol):
                dummy = Chem.ReplaceSubstructs(dummy, Substruct, Replacement, True)[0]
        rhs_options = product_options(dummy)
        lhs_addition_options = reactant_options(rhs_options)
        lhs_addition_options.append(input_mol)
        input_index = lhs_addition_options.index(input_mol)
        if lhs_required:
            if isinstance (lhs_required, list):
                for mol in lhs_required:
                    lhs_addition_options.append(mol)
            elif isinstance (lhs_required, Chem.Mol):
                    lhs_addition_options.append(lhs_required)
                
        if rhs_required:
            if isinstance (rhs_required, list):
                for mol in rhs_required:
                    append_unique(rhs_options, mol)
            elif isinstance (rhs_required, Chem.Mol):
                append_unique(rhs_options, rhs_required)
        
        
        x_vars = [LpVariable(f"x_{i}", 0, None, LpInteger) for i in range(len(rhs_options))]
        y_vars = [LpVariable(f"y_{j}", 0, None, LpInteger) for j in range(len(lhs_addition_options))]
        prob += y_vars[input_index] == 1       
        if lhs_required:
            if isinstance (lhs_required, list):
                for mol in lhs_required:
                    lhs_r_idx = lhs_addition_options.index(mol) 
                    prob += y_vars[lhs_r_idx] == 1
            elif isinstance (lhs_required, Chem.Mol):
                lhs_r_idx = lhs_addition_options.index(lhs_required) 
                prob += y_vars[lhs_r_idx] == 1
        if rhs_required:
            if isinstance (rhs_required, list):
                for mol in rhs_required:
                    rhs_r_idx = rhs_options.index(mol) 
                    prob += x_vars[rhs_r_idx] == 1
            elif isinstance (rhs_required, Chem.Mol):
                rhs_r_idx = rhs_options.index(rhs_required) 
                prob += x_vars[rhs_r_idx] == 1
        
        
    
    
    
        if not rhs_options:
            print("Error: No RHS molecules found.")
            return [], []
    
        bond_types_rhs = [count_bonds(mol) for mol in rhs_options]
        bond_types_lhs = [count_bonds(mol) for mol in lhs_addition_options]
        hydrogen_rhs = [count_hydrogens(mol) for mol in rhs_options]
        hydrogen_lhs = [count_hydrogens(mol) for mol in lhs_addition_options]
        for k in set().union(*bond_types_rhs, *bond_types_lhs):
            prob += lpSum(x_vars[i] * bond_types_rhs[i].get(k, 0) for i in range(len(rhs_options))) == \
                    lpSum(y_vars[j] * bond_types_lhs[j].get(k, 0) for j in range(len(lhs_addition_options)))
    
        for t in set().union(*hydrogen_rhs, *hydrogen_lhs):
            prob += lpSum(x_vars[i] * hydrogen_rhs[i].get(t, 0) for i in range(len(rhs_options))) == \
                    lpSum(y_vars[j] * hydrogen_lhs[j].get(t, 0) for j in range(len(lhs_addition_options)))
        
        solver = PULP_CBC_CMD(msg=False)
        prob.solve(solver)
    
        solution_x = [int(var.varValue) for var in x_vars]
        solution_y = [int(var.varValue) for var in y_vars]
    
        balanced_rhs = [(rhs_options[i], solution_x[i]) for i in range(len(rhs_options)) if solution_x[i] > 0]
        balanced_lhs = [(lhs_addition_options[j], solution_y[j]) for j in range(len(lhs_addition_options)) if solution_y[j] > 0]
        print("Solver status:", LpStatus[prob.status])
        return balanced_rhs, balanced_lhs, LpStatus[prob.status]
    
    
    def count_bonds(mol):
        bond_counts = {}
        for bond in mol.GetBonds():
            if bond.GetBeginAtom().GetSymbol()== 'H' or bond.GetEndAtom().GetSymbol()== 'H':
                continue 
            atom1 = bond.GetBeginAtom()
            atom2 = bond.GetEndAtom()
    
            # Create a tuple where atom order doesn't matter by sorting the atoms based on their symbol and hybridization
            atom_pair = tuple(sorted(
                [(atom1.GetSymbol(), atom1.GetHybridization()), 
                 (atom2.GetSymbol(), atom2.GetHybridization())]
            ))
    
            bond_type = (atom_pair, bond.GetBondType())
            bond_counts[bond_type] = bond_counts.get(bond_type, 0) + 1
    
        return bond_counts
    
    def count_hydrogens(mol):
        hydrogen_counts = {}
        mol = Chem.MolFromSmiles(Chem.MolToSmiles(mol))
        for atom in mol.GetAtoms():
            key = (atom.GetSymbol(), atom.GetHybridization(), atom.GetNumExplicitHs())
            hydrogen_counts[key] = hydrogen_counts.get(key, 0) + 1
        return hydrogen_counts
    return Balance(input_mol)


#def all_test(input_mol):
#    balanced_rhs, balanced_lhs = Isogyric(input_mol)
#
#    print("Balanced Isogyric RHS molecules with coefficients:")
#    for mol, coeff in balanced_rhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#
#
#    print("\nBalanced Isogyric LHS molecules with coefficients:")
#    for mol, coeff in balanced_lhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#    
#    print("\nIsodesmic:")
#    
#    balanced_rhs, balanced_lhs = Isodesmic(input_mol)
#
#    print("Balanced Isodesmic RHS molecules with coefficients:")
#    for mol, coeff in balanced_rhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#
#
#    print("\nBalanced Isodesmic LHS molecules with coefficients:")
#    for mol, coeff in balanced_lhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#    
#    
#    print("\nHypohomodesmotic:")
#    balanced_rhs, balanced_lhs = Hypohomodesmotic(input_mol)
#    
#    print("Balanced Hypohomodesmotic RHS molecules with coefficients:")
#    for mol, coeff in balanced_rhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#    
#    print("\nBalanced Hypohomodesmotic LHS molecules with coefficients:")
#    for mol, coeff in balanced_lhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#    
#    print("\nHomodesmotic:")
#    
#    balanced_rhs, balanced_lhs = Homodesmotic(input_mol)
#
#    print("Balanced Homodesmotic RHS molecules with coefficients:")
#    for mol, coeff in balanced_rhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#
#
#    print("\nBalanced Homodesmotic LHS molecules with coefficients:")
#    for mol, coeff in balanced_lhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#        
#        
#def isog_test(input_mol, lhs_required=None, rhs_required=None, Substruct=None, Replacement=None):
#    balanced_rhs, balanced_lhs = Isogyric(input_mol, lhs_required = lhs_required, rhs_required = rhs_required, Substruct=Substruct, Replacement = Replacement)
#    print("Balanced RHS molecules with coefficients:")
#    for mol, coeff in balanced_rhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#
#
#    print("\nBalanced LHS molecules with coefficients:")
#    for mol, coeff in balanced_lhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#
#
#        
#
#
#def isod_test(input_mol, lhs_required=None, rhs_required=None, Substruct=None, Replacement=None):
#    balanced_rhs, balanced_lhs = Isodesmic(input_mol, lhs_required = lhs_required, rhs_required = rhs_required, Substruct=Substruct, Replacement = Replacement)
#    print("Balanced RHS molecules with coefficients:")
#    for mol, coeff in balanced_rhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#
#
#    print("\nBalanced LHS molecules with coefficients:")
#    for mol, coeff in balanced_lhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#
#
#        
# 
#        
#def hypo_test(input_mol, lhs_required=None, rhs_required=None, Substruct=None, Replacement=None):
#    balanced_rhs, balanced_lhs = Hypohomodesmotic(input_mol, lhs_required = lhs_required, rhs_required = rhs_required, Substruct=Substruct, Replacement = Replacement)
#    print("Balanced RHS molecules with coefficients:")
#    for mol, coeff in balanced_rhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#
#
#    print("\nBalanced LHS molecules with coefficients:")
#    for mol, coeff in balanced_lhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#
#
#        
#
#def homo_test(input_mol, lhs_required=None, rhs_required=None, Substruct=None, Replacement=None):
#    balanced_rhs, balanced_lhs = Homodesmotic(input_mol, lhs_required = lhs_required, rhs_required = rhs_required, Substruct=Substruct, Replacement = Replacement)
#    print("Balanced RHS molecules with coefficients:")
#    for mol, coeff in balanced_rhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#
#
#    print("\nBalanced LHS molecules with coefficients:")
#    for mol, coeff in balanced_lhs:
#        print(f"{coeff} * {Chem.MolToSmiles(mol)}")
#





reaction_map = {
    "homodesmotic": Homodesmotic,
    "isodesmic": Isodesmic,
    "isogyric": Isogyric,
    "hypohomodesmotic": Hypohomodesmotic,
}

def parse_smiles_list(arg):
    if isinstance(arg, list):
        smiles_list = []
        for item in arg:
            if ',' in item:
                smiles_list.extend(item.split(','))
            else:
                smiles_list.append(item)
    else:
        smiles_list = arg.split(',') if ',' in arg else [arg]

    mols = []
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            raise argparse.ArgumentTypeError(f"Invalid SMILES: {smi}")
        mols.append(mol)
    return mols

# Argument parsing
parser = argparse.ArgumentParser(description="Run reaction balancing (e.g. Homodesmotic, Isodesmic, etc.)")
parser.add_argument("reaction_type", choices=reaction_map.keys(), help="Type of reaction")
parser.add_argument("input", type=str, help="Input molecule SMILES")

# Optional arguments for LHS, RHS, Substruct, and Replacement
parser.add_argument("--lhs", nargs="+", type=str, help="LHS required molecules (SMILES or comma-separated list)")
parser.add_argument("--rhs", nargs="+", type=str, help="RHS required molecules (SMILES or comma-separated list)")
parser.add_argument("--substruct", nargs="+", type=str, help="Substructures to replace (SMILES or list)")
parser.add_argument("--replacement", nargs="+", type=str, help="Replacement structures (SMILES or list)")

args = parser.parse_args()

# Convert the input SMILES to a Mol object
input_smiles = str(args.input)  # Ensure input is a string
input_mol = Chem.AddHs(Chem.MolFromSmiles(input_smiles))
if input_mol is None:
    raise argparse.ArgumentTypeError(f"Invalid SMILES: {args.input}")

# Parse optional arguments (LHS, RHS, etc.)
lhs_required = parse_smiles_list(args.lhs) if args.lhs else None
rhs_required = parse_smiles_list(args.rhs) if args.rhs else None
Substruct = parse_smiles_list(args.substruct) if args.substruct else None
Replacement = parse_smiles_list(args.replacement) if args.replacement else None

reaction_fn = reaction_map[args.reaction_type.lower()]
rhs, lhs, status = reaction_fn(input_mol, lhs_required, rhs_required, Substruct, Replacement)
if status != 'Optimal':
    print(status)
else:
    print("LHS:")
    for m, c in lhs:
        print(f"{c} * {Chem.MolToSmiles(m)}")

    print("\nRHS:")
    for m, c in rhs:
        print(f"{c} * {Chem.MolToSmiles(m)}") 
